const express = require('express');
const session = require('express-session');
const bcrypt = require('bcrypt');
const Database = require('better-sqlite3');
const bodyParser = require('body-parser');
const path = require('path');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const csrf = require('csurf');
const cookieParser = require('cookie-parser');
const { body, validationResult } = require('express-validator');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// CRITICAL: Validate SESSION_SECRET exists and is strong
if (!process.env.SESSION_SECRET || process.env.SESSION_SECRET === 'your-secret-key-change-in-production') {
  console.error('❌ CRITICAL ERROR: SESSION_SECRET must be set in .env file and cannot be the default value!');
  console.error('Generate a strong secret with: node -e "console.log(require(\'crypto\').randomBytes(32).toString(\'hex\'))"');
  process.exit(1);
}

// Check if running in production
const isProduction = process.env.NODE_ENV === 'production';

// Initialize SQLite Database
const db = new Database('prompts.db');

// Create tables if they don't exist
db.exec(`
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  );

  CREATE TABLE IF NOT EXISTS saved_prompts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    template_name TEXT NOT NULL,
    category TEXT NOT NULL,
    prompt_text TEXT NOT NULL,
    inputs JSON,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
  );

  CREATE TABLE IF NOT EXISTS usage_stats (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    template_name TEXT NOT NULL,
    category TEXT NOT NULL,
    used_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
  );
`);

// Middleware
// 1. Security Headers with Helmet
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));

// 2. Rate Limiting
// General API rate limiter
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
});

// Strict rate limiter for authentication endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Limit each IP to 5 login/register attempts per windowMs
  message: 'Too many authentication attempts, please try again after 15 minutes.',
  skipSuccessfulRequests: true, // Don't count successful logins
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply rate limiting
app.use('/api/', apiLimiter);

// 3. Body parsing
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// 4. Cookie parser (required for CSRF)
app.use(cookieParser());

// 5. Static files
app.use(express.static(path.join(__dirname, 'public')));

// 6. Session configuration
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: { 
    secure: isProduction, // Use secure cookies in production (requires HTTPS)
    httpOnly: true, // Prevents client-side JS from accessing the cookie
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    sameSite: 'strict' // CSRF protection
  },
  name: 'sessionId', // Don't use default session cookie name
}));

// 7. CSRF Protection
const csrfProtection = csrf({ cookie: true });

// Helper function to send CSRF token to frontend
function sendCsrfToken(req, res, next) {
  res.cookie('XSRF-TOKEN', req.csrfToken(), {
    httpOnly: false, // Must be readable by JavaScript
    secure: isProduction,
    sameSite: 'strict'
  });
  next();
}

// Authentication middleware
function requireAuth(req, res, next) {
  if (req.session.userId) {
    next();
  } else {
    res.status(401).json({ error: 'Authentication required' });
  }
}

// Input validation middleware
function handleValidationErrors(req, res, next) {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ error: errors.array()[0].msg });
  }
  next();
}

// Routes

// Serve login page
app.get('/login', csrfProtection, sendCsrfToken, (req, res) => {
  if (req.session.userId) {
    return res.redirect('/dashboard');
  }
  res.sendFile(path.join(__dirname, 'public', 'login.html'));
});

// Serve signup page
app.get('/signup', csrfProtection, sendCsrfToken, (req, res) => {
  if (req.session.userId) {
    return res.redirect('/dashboard');
  }
  res.sendFile(path.join(__dirname, 'public', 'signup.html'));
});

// Serve dashboard (protected)
app.get('/dashboard', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'dashboard.html'));
});

// API: Register new user
app.post('/api/register',
  authLimiter, // Rate limiting
  csrfProtection, // CSRF protection
  [
    // Input validation
    body('username')
      .trim()
      .isLength({ min: 3, max: 30 }).withMessage('Username must be 3-30 characters')
      .isAlphanumeric().withMessage('Username must contain only letters and numbers')
      .escape(),
    body('email')
      .trim()
      .isEmail().withMessage('Must be a valid email address')
      .normalizeEmail()
      .isLength({ max: 100 }).withMessage('Email is too long'),
    body('password')
      .isLength({ min: 8 }).withMessage('Password must be at least 8 characters')
      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/).withMessage('Password must contain at least one uppercase letter, one lowercase letter, and one number')
  ],
  handleValidationErrors,
  async (req, res) => {
  const { username, email, password } = req.body;

  try {
    // Check if user already exists
    const existingUser = db.prepare('SELECT id FROM users WHERE username = ? OR email = ?').get(username, email);
    
    if (existingUser) {
      return res.status(400).json({ error: 'Username or email already exists' });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Insert user
    const result = db.prepare('INSERT INTO users (username, email, password) VALUES (?, ?, ?)').run(username, email, hashedPassword);

    // Create session
    req.session.userId = result.lastInsertRowid;
    req.session.username = username;

    res.json({ 
      success: true, 
      message: 'Registration successful',
      userId: result.lastInsertRowid 
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

// API: Login
app.post('/api/login',
  authLimiter, // Rate limiting
  csrfProtection, // CSRF protection
  [
    // Input validation
    body('username').trim().notEmpty().withMessage('Username is required').escape(),
    body('password').notEmpty().withMessage('Password is required')
  ],
  handleValidationErrors,
  async (req, res) => {
  const { username, password } = req.body;

  try {
    // Find user
    const user = db.prepare('SELECT * FROM users WHERE username = ? OR email = ?').get(username, username);

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Verify password
    const validPassword = await bcrypt.compare(password, user.password);

    if (!validPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Create session
    req.session.userId = user.id;
    req.session.username = user.username;

    res.json({ 
      success: true, 
      message: 'Login successful',
      username: user.username 
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// API: Logout
app.post('/api/logout', csrfProtection, (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ error: 'Logout failed' });
    }
    res.json({ success: true, message: 'Logged out successfully' });
  });
});

// API: Get current user
app.get('/api/user', requireAuth, (req, res) => {
  const user = db.prepare('SELECT id, username, email, created_at FROM users WHERE id = ?').get(req.session.userId);
  res.json(user);
});

// API: Save prompt
app.post('/api/prompts/save',
  requireAuth,
  csrfProtection,
  [
    body('templateName').trim().notEmpty().withMessage('Template name is required').escape(),
    body('category').trim().notEmpty().withMessage('Category is required').escape(),
    body('promptText').trim().notEmpty().withMessage('Prompt text is required').isLength({ max: 10000 }).withMessage('Prompt text is too long')
  ],
  handleValidationErrors,
  (req, res) => {
  const { templateName, category, promptText, inputs } = req.body;

  try {
    const result = db.prepare(
      'INSERT INTO saved_prompts (user_id, template_name, category, prompt_text, inputs) VALUES (?, ?, ?, ?, ?)'
    ).run(req.session.userId, templateName, category, promptText, JSON.stringify(inputs || {}));

    res.json({ success: true, promptId: result.lastInsertRowid });
  } catch (error) {
    console.error('Save prompt error:', error);
    res.status(500).json({ error: 'Failed to save prompt' });
  }
});

// API: Get user's saved prompts
app.get('/api/prompts', requireAuth, (req, res) => {
  try {
    const prompts = db.prepare(
      'SELECT * FROM saved_prompts WHERE user_id = ? ORDER BY created_at DESC'
    ).all(req.session.userId);

    // Parse JSON inputs
    prompts.forEach(prompt => {
      prompt.inputs = JSON.parse(prompt.inputs);
    });

    res.json(prompts);
  } catch (error) {
    console.error('Get prompts error:', error);
    res.status(500).json({ error: 'Failed to retrieve prompts' });
  }
});

// API: Delete saved prompt
app.delete('/api/prompts/:id', requireAuth, csrfProtection, (req, res) => {
  const promptId = req.params.id;

  try {
    const result = db.prepare(
      'DELETE FROM saved_prompts WHERE id = ? AND user_id = ?'
    ).run(promptId, req.session.userId);

    if (result.changes === 0) {
      return res.status(404).json({ error: 'Prompt not found' });
    }

    res.json({ success: true, message: 'Prompt deleted' });
  } catch (error) {
    console.error('Delete prompt error:', error);
    res.status(500).json({ error: 'Failed to delete prompt' });
  }
});

// API: Track usage
app.post('/api/usage',
  requireAuth,
  csrfProtection,
  [
    body('templateName').trim().notEmpty().withMessage('Template name is required').escape(),
    body('category').trim().notEmpty().withMessage('Category is required').escape()
  ],
  handleValidationErrors,
  (req, res) => {
  const { templateName, category } = req.body;

  try {
    db.prepare(
      'INSERT INTO usage_stats (user_id, template_name, category) VALUES (?, ?, ?)'
    ).run(req.session.userId, templateName, category);

    res.json({ success: true });
  } catch (error) {
    console.error('Usage tracking error:', error);
    res.status(500).json({ error: 'Failed to track usage' });
  }
});

// API: Get user statistics
app.get('/api/stats', requireAuth, (req, res) => {
  try {
    const totalPrompts = db.prepare(
      'SELECT COUNT(*) as count FROM saved_prompts WHERE user_id = ?'
    ).get(req.session.userId).count;

    const totalUsage = db.prepare(
      'SELECT COUNT(*) as count FROM usage_stats WHERE user_id = ?'
    ).get(req.session.userId).count;

    const categoryStats = db.prepare(
      'SELECT category, COUNT(*) as count FROM usage_stats WHERE user_id = ? GROUP BY category'
    ).all(req.session.userId);

    const recentActivity = db.prepare(
      'SELECT template_name, category, used_at FROM usage_stats WHERE user_id = ? ORDER BY used_at DESC LIMIT 10'
    ).all(req.session.userId);

    res.json({
      totalPrompts,
      totalUsage,
      categoryStats,
      recentActivity
    });
  } catch (error) {
    console.error('Stats error:', error);
    res.status(500).json({ error: 'Failed to retrieve statistics' });
  }
});

// Redirect root to index or dashboard
app.get('/', (req, res) => {
  if (req.session.userId) {
    res.redirect('/dashboard');
  } else {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
